<?php

namespace Bracelet;
/**
 * Файл вспомогательных функций для логирования.
 *
 * Содержит публичные функции `logError` и `logInfo`
 * для записи сообщений разных уровней. Общая логика вынесена во
 * внутреннюю функцию `writeLog`. Путь к файлу логов может быть
 * переопределён через переменную окружения `LOG_FILE`.
 */

/**
 * Возвращает путь к файлу логов приложения.
 *
 * Значение берётся из переменной окружения `LOG_FILE`. Если переменная
 * не задана или пуста, используется путь по умолчанию
 * `__DIR__ . '/logs/app.log'`.
 *
 * @internal
 *
 * @return string Путь к лог‑файлу.
 */
function getLogFilePath(): string
{
    // Получаем значение переменной окружения, если оно существует.
    $path = getenv('LOG_FILE');

    // Если переменная не установлена или пуста, возвращаем стандартный путь.
    return $path === false || $path === ''
        ? __DIR__ . '/logs/app.log'
        : $path;
}

/**
 * Приватная функция, осуществляющая запись строки в файл логов.
 *
 * Выполняет подготовку каталога, экранирование перевода строк
 * и добавление временной метки с указанием уровня сообщения.
 * Функция помечена как `@internal`, поскольку предполагается
 * её использование только внутри данного файла.
 *
 * @internal
 *
 * @param string $message Текст сообщения, подлежащего записи.
 * @param string $level   Уровень логирования (например, `error` или `info`).
 *
 * @return void
 */
function writeLog(string $message, string $level): void
{
    // Вычисляем актуальный путь к файлу логов.
    $logFile = getLogFilePath();

    // Определяем каталог, где должен находиться файл логов.
    $dir = dirname($logFile);
    // Если каталога нет, создаём его рекурсивно.
    if (!is_dir($dir)) {
        // Ограничиваем права доступа к каталогу логов.
        mkdir($dir, 0755, true);
    }

    // Удаляем из сообщения все переводы строк,
    // чтобы не нарушить структуру файла логов.
    $safeMessage = preg_replace("/[\r\n]+/", ' ', $message);

    // Формируем строку с текущей временной меткой.
    $time = date('c');

    // Строим итоговую запись с указанием уровня.
    $entry = sprintf('[%s] [%s] %s\n', $time, $level, $safeMessage);

    // Пытаемся записать строку в файл логов.
    $result = error_log($entry, 3, $logFile);

    // Если запись не удалась, сообщаем об этом через предупреждение.
    if ($result === false) {
        trigger_error(
            sprintf(
                'Не удалось записать сообщение в лог-файл: %s',
                $logFile
            ),
            E_USER_WARNING
        );
    }
}

/**
 * Записывает сообщение об ошибке в лог приложения.
 *
 * Вся логика записи инкапсулирована во внутренней функции `writeLog`,
 * здесь лишь передаётся уровень `error`.
 *
 * @param string $message Текст ошибки, которую требуется зафиксировать.
 *
 * @return void
 */
function logError(string $message): void
{
    // Перенаправляем сообщение во внутренний механизм логирования.
    writeLog($message, 'error');
}

/**
 * Записывает информационное сообщение в лог приложения.
 *
 * Вся служебная работа выполняется `writeLog`,
 * поэтому здесь только передаём уровень `info`.
 *
 * @param string $message Текст информационного сообщения.
 *
 * @return void
 */
function logInfo(string $message): void
{
    // Вызов универсальной функции записи с уровнем `info`.
    writeLog($message, 'info');
}
